#Collection(컬렉션)
	: 많은 양의 데이터를 손쉽게 보관할 수 있는 클래스들의 집합
	
	배열을 이용해서도 많은 양의 데이터를 보관할 수 있다.

	배열의 단점
		크기를 변경할 수 없다.
		(즉, 한번 데이터의 양을 결정하면 그 양보다 많은 데이터는 보관할 수 없다.)
		데이터의 입출력에 많은 제약사항을 갖는다.
		(반드시 위치를 알아야 데이터를 입력 또는 출력할 수 있다.)
		
		
종류]
	
	1. List 계열
	
		특징]
			1) 입력한 순서를 보장한다. 단, 처리속도가 느리다.
			
			2) 중복데이터를 허용한다.
			
	
	2. Set 계열
	
		특징]
			1) 입력순서를 보장하지 않는다.
				//나름의 규칙을 가지고 데이터를 정렬하여 보관한다.
				//처리속도는 빠르다.
				
			2) 중복데이터가 다시 저장되면 먼저 데이터를 삭제한 후 저장한다.
				//중복데이터는 한번만 저장된다.
	
				
	3. Map 계열 :: sequence 자료형이 아니다.(인덱스가 없다.)
		
		특징]
			1) 데이터를 그 데이터를 구분하는 기 값과 데이터를 한 쌍으로 만들어 저장한다.
			
			2) 입력순서는 보장하지 않는다.
				//키값으로 정렬되기 때문이다.
				
			3) 같은 키 값이 입력되면 먼저 데이터는 삭제한다.
				//데이터는 같아도 되나, 키값은 같으면 안된다.
				
				
	참고]
		List 계열과 Set 계열은 상위클래스가 같지만,
		Map 계열은 다르다.
		//List, Set은 다형성 처리가 가능하지만(서로 변환가능하지만)
		Map은 독립적으로 변환이 불가하다.

==========================================================================================

#List 계열

	1. Vector
		: 내부적으로는 배열형태를 만들어서 데이터를 보관하는 컬렉션의 한 종류
		
		장점]
			입력속도와 검색속도는 빠르다.
			
		단점]
			중간의 데이터를 삽입하거나, 데이터를 삭제하는 속도는 느리다.
			
		결론]
			데이터의 변화가 거의 없는 프로그램에서 많이 사용된다.
			
			
		생성방법(생성자함수)]
		
			1) Vector()
				: 배열의 크기를 10으로 정한 상태에서 벡터를 만들어준다.
				물론 데이터가 증가하면 크기는 자동변경된다.
				이때, 변경되는 규칙은
								이전크기 * 2		이다.
								
				단점으로는 크기의 낭비가 있을 수 있다는 점이다.
				
			2) Vector(Collection c)
				: 다른 컬렉션 데이터를 복사해서 벡터를 만들어준다.
				
			3) Vector(int initialCapacity)
				: 사용자가 직접 배열의 크기를 정하면서 벡터를 만들어준다.
			
			****			
			4) Vector(int initialCapacity, int capacityIncrement)
				: 3번 + 데이터의 양이 많아지면 추가될 배열의 크기를 지정해서 만든다.
				
			
			참고]
				컬렉션은 데이터의 양에 관계없이 항상 데이터를 입력받을 수 있다.
				(왜냐하면 따로 사이즈 정의가 되어있지 않으므로)
				이때 데이터를 입력받을 공간을 확보해야하는데,
				규칙이
						현재크기 * 2	이다.
						
		주요함수]
			1. 데이터를 입력하는 함수
				add(Object e)
				add(int index, Object element)
				addAll(Collection c)
				addAll(int index, Collection c)
				addElement(Object obj)
				insertElementAt(Object obj, int index)
					//이런식으로 뒤에 Element가 붙으면 매개변수 순서가 obj, index 이다.
					
			2. 데이터를 수정하는 함수
				set(int index, Object element)
				setElementAs(Object obj, int index)
				
			3. 데이터를 꺼내는 함수
				get(int index)
				elementAt(int index)
				firstElement()
				lastElement()
				elements()
				
		참고]
			E, V, K 라고 표현한 것들은 Object를 의미하는 제너릭이다.
			(컬렉션에서는 모두 객체로 받아들이기 때문이다.)

==========================================================================================

	2. ArrayList
		: Vector의 신버전으로,
		역시 배열형태로 데이터를 관리하기 때문에 Vector의 특징을 그래도 가지고 있다.
		
		다만, Thread에서 동기화 처리를 자동으로 해주지않는다.
		그러다보니 데이터처리속도가 벡터보다 빠르다.
		요사이는 Vector 보다는 ArrayList 사용을 선호하는 경향이 있다.
		
	cf) Thread, 동기화, 직렬화 etc.
	
		
		사용방법]
		
			Vector 와 유사하다.
			
			참고]
				List 계열의 주소를 출력하면,
				마치 데이터가 출력된 것처럼 보이지만
				이것은 toString() 함수를 Overriding 해 놓았기 때문에,
				출력만 되는 것이다.
				절대로 데이터 출력을 위해 toString()을 사용하지 말 것!
				이것도 역시 내용만 살펴보는 함수기 때문이다.
				
				
	3. LinkedList
		: 내부적으로 이중 연결 리스트 방식으로 데이터를 보관하는 방식의 일종
		
		장점]
			데이터를 중간에 끼워넣는 작업, 삭제 작업에서 속도가 빠르다.
			(데이터를 찾아가는 속도가 빠르다는 뜻이다.)
			
		단점]
			데이터를 누적시키는 작업에서는 속도가 느리다.
			
	
	참고클래스
	
		Iterator(순차적으로 데이터를 꺼내기 위한 클래스)
			: 컬렉션은 많은 클래스의 집합이고, 그 형태도 다르다.
			그런데 클래스들끼리 혼용될 수는 있을 것이다.
			이때 그 안에 들어있는 데이터를 꺼내는 방식은 약간씩 다를 수 있다.
			List에서 데이터를 꺼내는 방식과 Set에서 데이터를 꺼내는 방식이 다르다는 것이다.
				//꺼내는 작업은 데이터원본을 다르게 만들어야한다.
				
			그래서 데이터를 꺼내기 위해서만 사용하는 클래스를 따로 만들어 놓았다.
			그것이 Iterator 클래스이다.
			
			즉, List, Set 이던 Iterator 로 변환만 시켜준다면,
			같은 방식으로 꺼낼 수 있으므로,
			꺼내는 source(코드)를 통일하게 하여 꺼낼 수 있다.
			
			
			특징]
				StringTokenizer 와 유사하게 순차적으로 꺼낼 수 있고,
				한번 꺼낸 데이터는 자동삭제된다. (buffer 메모리)
			
==========================================================================================

