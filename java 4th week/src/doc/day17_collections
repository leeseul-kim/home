Reviews]
	배열을 관리하는 클래스		-	Arrays
	객체를 관리하는 클래스		-	Objects
	...
	
	
#Collections 클래스

	: 이것은 이름은 컬렉션이지만, 컬렉션은 아니고
	컬렉션을 이용할 때 필요한 부가적인 기능을 제공하는 
	utility 적인 클래스이다.
	
	
	주의]
		컬렉션을 사용할 때
		List를 달라고 하면(매개변수에 List 타입으로 정의가 되어있으면)
		List 계열을 입력하면 된다.
		Set을 달라고 하면 Set 계열을 입력하면 된다.
		Collection을 달라고 하는 경우는 List 또는 Set 계열 중 하나를 입력하면 된다.
		Map을 달라고 하면 Map 계열을 주면 된다.
			//Map은 다형성처리가 되지 않는다.
			
			
	참고]
		일반적인 정렬은 오름차순으로 정렬하게 된다.
		만약 정렬 방식을 변경하고자 한다면,
		sort(List list, Comparator c) 함수를 사용해야한다.
		
			정렬을 해주는 인터페이스를 2가지가 있는데, 이 두가지를 어떻게 써야하는지 의문이 생긴다.
				Comparable / Comparator
			보통 정렬에서는 기준을 어떤 것으로 해야하는지에 따라 다르다.
			
=====================================================================================================

#Set 계열

	특징]
	
		1. 입력한 순서대로 보관하고 있을 보장이 없다. 즉, 입력순서를 보장하지 못한다.
		(나름의 규칙에 따라서 내부적으로 정렬을 하여 보관하기 때문이다.)
		
		2. 중복된 데이터는 한번만 저장한다.
		(중복된 데이터가 입력될 경우에는 먼저 저장된 데이터를 지우고, 새로운 데이터를 입력한다.)
		즉, 교체한다는 이야기다.
		
		
	종류]
		
		1. HashSet
			: HashCode를 이용해서 정렬하여 보관하는 방식의 컬렉션이다.
			따라서, 우리가 상상하는 정렬은 이루어지지않는다.
			
				-몰라도되는 내용-
				Hash(int initialCapacity, float loadFactor)
					: loadFactor 는 HashCode 값을 만드는 규칙에 사용할 상수값
					사용자가 지정하면서 해쉬테이블을 만들어 사용한다.
					
		*****
		참고]
		
			Set 계열은 데이터를 꺼내는 함수는 존재하지 않는다.
				: 왜냐하면, 개발자는 데이터가 저장된 장소를 모르기 때문이다.
				따라서 특정 위치를 지정하면서 데이터를 꺼낼 수 없다.
				그렇기 때문에 Iterator로 변환하여 순서대로 꺼내요 사용하도록 한다.
	
		2. TreeSet
			: 내부적으로 TreeSort라는 알고리즘을 이용하여 데이터를 보관하는 기능을 가진 컬렉션이다.
			
			
			특징]
			
				우리가 상상하는 정렬방식에 이용한다.				
				ex. 오름차순, 내림차순, etc.
			
			
			생성방법]
				
				TreeSet(Comparator comparator)
					: 정렬 방식을 변경하여 TreeSet을 만든다.
				
				TreeSet(SortedSet<E> s)
					: TreeSet을 이용하여 다시 TreeSet을 만든다.
			
			
			참고함수]
				
				subSet()
					: 하나의 Set에 담긴 내용 중에서 특정부분만 골라서 새로운 Set을 만드는 함수
					그러므로, 반환값은 Set이다.
				
				headSet(E toElement)
					: 처음부터 지정한 부분까지 골라서 새로운 Set을 만든다.
					
				tailSet(E fromElement)
					: 지정한 부분부터 마지막까지 골라서 새로운 Set을 만든다.

=====================================================================================================

#Map 계열
	: 하나의 데이터를 그 데이터를 구분할 수 있는 키 값과 한쌍으로 만들어서
	데이터를 기억하는 컬렉션의 일종.
	그리고 사용할 경우에는 키 값을 이용해서 데이터를 꺼낼 수 있도록 해 놓았다.
	
	Map 계열은 많은 양의 데이터를 보관하는 용도보다는
	데이터를 쉽게 구분하여 사용할 목적으로 사용된다.
	
	
	Hashtable / HashMap
		: Hashtable이 이전 버전에서 나온 클래스이고,
		HashMap이 다음 버전에서 나온 클래스이므로,
		HashMap을 사용하도록 권장하고 있다.
		
		내부적으로 키 값을 해쉬테이블을 이용하여 정렬해서 보관한다.
		
		
		주요함수]
		
			put(Object key, Object value)
				: 데이터를 입력하는 함수
				//List, Set의 경우 데이터를 입력할 때 쓰는 함수는 add이다.
				
			get(Object key)
				: 필요한 데이터를 꺼내오는 함수
				
		
		참고함수]
		
			values()
				: 데이터만 꺼내서 사용할 수 있다.
				
			keys()
				: 키 값만 꺼내서 사용할 수 있다.
				
		
			참고]
				
				keys()로 꺼낸 데이터는 Enumeration으로 변환한다.
				
				Enumeration(열거) 클래스	
				//이 클래스는 Iterator의 구버전이다.
				즉, 데이터를 순차적으로 꺼낼 수 있는 것이다.
				
				
			참고]
			
				HashMap에서는 키 값만 꺼내는 함수가 keySet()으로 변경되었다.
				이때, 반환값으로는 Set<> 이 있는데 Set을 사용하는 이유는
				키 값이 중복이 되면 안되기 때문이다. (Set 역시 중복데이터는 취급하지않는다.)
				이후, 키 값을 꺼내려고 한다면, Set에서 Iterator 를 사용하거나,
				ArrayList(Collection c)	 생성자함수를 사용하면 된다.
				
			
			참고]
			
				entrySet()
					: Map은 반드시 키값을 알아야 데이터를 꺼낼 수 있다.
					(물론 다른 방식으로 꺼낼 수 있기도 한다.)
					//그래서 키 값과 데이터를 Set으로 묶어주는 것이다. 
					
				문제]
					Map은 항상 두개가 있어야 저장이 된다.
					Set은 항상 한개만 저장이 된다.
					따라서, 어떻게 해서든지 key, value 를 하나로 묶어야만 Set에
					한 세트로 저장이 가능하다.
					
					이것을 해결하기 위해서 클래스(예로, VO 클래스// 보통 한 쌍(row)를 위한 것)가 존재한다.
					그 클래스가 바로
								Map.Entry
					라는 클래스이다.
					이 클래스 안에는 key와 value 변수를 은닉화(접근지정자를 private으로 하는 것) 시켜놓고,
					이 변수를 사용할 수 있는 함수(Setter, Getter)를 제공하고 있다.
					이러한 변수들과 이러한 함수들을 캡슐화 해 놓은 클래스이다.